import asyncio
import shlex
import sys
import typing as t
from dataclasses import dataclass

import cyclopts
import dreadnode as dn
import litellm
import rigging as rg
from loguru import logger

if t.TYPE_CHECKING:
    from loguru import Record as LogRecord

# CLI

app = cyclopts.App()


@cyclopts.Parameter(name="*", group="args")
@dataclass
class Args:
    model: str
    """Model to use for inference"""
    target: str
    """Target IP addres ot CIDR range uri to pentest"""
    max_steps: int = 50
    """Maximum number of iterations per agent"""
    log_level: str = "INFO"
    """Log level (DEBUG, INFO, WARNING, ERROR, CRITICAL)"""


@cyclopts.Parameter(name="*", group="dreadnode")
@dataclass
class DreadnodeArgs:
    server: str | None = None
    """Dreadnode server URL"""
    token: str | None = None
    """Dreadnode API token"""
    project: str = "pentest agent"
    """Dreadnode project name"""
    console: t.Annotated[bool, cyclopts.Parameter(negative=False)] = False
    """Show span information in the console"""


def log_formatter(record: "LogRecord") -> str:
    return "".join(
        (
            "<green>{time:HH:mm:ss.SSS}</green> | ",
            "<dim>{extra[prefix]}</dim> " if record["extra"].get("prefix") else "",
            "<level>{message}</level>\n",
        ),
    )


@dn.task(name="nmap", log_output=False)
async def nmap(target: str) -> str:
    """
    Scan target for hosts and services.
    """
    logger.info(f"Agent scanning target: {target}")

    cmd = f"nmap -sV -sC {shlex.quote(target)}"
    logger.debug(f"Running nmap command for: {target}")

    process = await asyncio.create_subprocess_shell(
        cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )

    stdout, stderr = await process.communicate()

    if process.returncode != 0:
        error_msg = stderr.decode().strip()
        logger.error(f"nmap command failed with exit code {process.returncode}: {error_msg}")
        return f"Error running nmap: {error_msg}"

    result = stdout.decode().strip()
    logger.debug("nmap scan completed successfully")
    return result


@dn.task(name="Report finding", log_output=False, log_inputs=False)
async def report_finding(
    type: t.Annotated[str, "Type of finding"],
    value: t.Annotated[str, "The finding data itself"],
    comment: t.Annotated[str, "Comment about the data"],
) -> str:
    """
    Report findings found in nmap, vulnerability scan, or metasploit command usage.

    When reporting a finding, follow these guidelines:
    - For hosts, report the IP address
    - For services, report the host, port and service name and version
    - For vulnerabiltiies, report the service and vulnerability information

    When reporting the `type`, use the following values:
    - host
    - service
    - vulnerability
    - exploited_vuln
    - other
    """
    logger.success(f"Reporting ({type})")
    logger.success(f"  |- {comment}")
    logger.success(f"  |= {value}")

    dn.log_output(
        "report",
        {
            "type": type,
            "value": value,
            "comment": comment,
        },
        to="run",
    )
    dn.log_metric("num_reports", 1, mode="count", to="run")

    return "Reported"


@dn.task(name="Give up", log_output=False)
async def give_up(reason: str) -> None:
    """
    Give up on your task.
    """
    logger.warning(f"Agent gave up: {reason}")
    dn.log_metric("agent_gave_up", 1)


@dn.task(name="Complete task", log_output=False)
async def complete_task(summary: str) -> None:
    """
    Complete your task.
    """
    logger.info(f"Agent completed the task: {summary}")
    dn.log_metric("agent_marked_complete", 1)


@app.default
async def agent(*, args: Args, dn_args: DreadnodeArgs | None = None) -> None:
    """
    Agent to pentest host or cidr range.
    """

    logger.remove()
    logger.add(sys.stderr, format=log_formatter, level=args.log_level)
    logger.enable("rigging")

    dn_args = dn_args or DreadnodeArgs()
    dn.configure(
        server=dn_args.server,
        token=dn_args.token,
        project=dn_args.project,
        console=dn_args.console,
        send_to_logfire=False,
    )

    with dn.run(), dn.task_span("Agent"):
        dn.log_params(
            model=args.model,
            max_steps=args.max_steps,
        )

        generator = rg.get_generator(args.model)
        chat = (
            await generator.chat(
                f"""
                As an authorized security testing assistant, Your task is to pentest the given host IP or CIDR range
                {args.target} using the nmap tool. You have permission to test all targets in scope.

                Report all findings you find using the provided tool.
                """,
            )
            .catch(
                *litellm.exceptions.LITELLM_EXCEPTION_TYPES,
                on_failed="include",
            )
            .using(
                nmap,
                report_finding,
                give_up,
                complete_task,
                max_depth=args.max_steps,
            )
            .run()
        )

        if chat.failed and chat.error:
            if isinstance(chat.error, rg.error.MaxDepthError):
                logger.warning(f"Max steps reached ({args.max_steps})")
                dn.log_metric("max_steps_reached", 1)
            else:
                logger.warning(f"Failed with {chat.error}")
                dn.log_metric("failed_chat", 1, mode="count")

        elif chat.last.role == "assistant":
            logger.info(str(chat.last))
            dn.log_output("last_message", chat.last.content)

    logger.info("Done.")


if __name__ == "__main__":
    app()
